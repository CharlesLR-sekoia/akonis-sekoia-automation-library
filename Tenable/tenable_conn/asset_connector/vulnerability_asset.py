from datetime import timedelta, datetime
from functools import cached_property
from typing import Generator
from enum import Enum

from tenable.io import TenableIO

from sekoia_automation.asset_connector import AssetConnector
from sekoia_automation.checkpoint import CheckpointTimestamp, TimeUnit
from sekoia_automation.asset_connector.models.ocsf.base import Product, Metadata
from sekoia_automation.asset_connector.models.ocsf.vulnerability import VulnerabilityOCSFModel, FindingInformation, CVE, \
    VulnerabilityDetails

from tenable_conn import TenableModule


class VulnerabilityState(Enum):
    OPEN = 'open'
    REOPENED = 'reopened'
    FIXED = 'fixed'


class VulnerabilitySeverity(Enum):
    LOW = 'low'
    Medium = 'medium'
    High = 'high'
    CRITICAL = 'critical'


class TenableAssetConnector(AssetConnector):
    module: TenableModule

    STATES: list[VulnerabilityState] = []
    SEVERITIES: list[VulnerabilitySeverity] = []
    PRODUCT: str = "Tenable"
    PRODUCT_TYPE: str = "Tenable Vulnerability Management"
    CLIENT_PRODUCT:str = "Sekoia Defend" #Added to User-Agent
    CLIENT_VENDOR:str = "Sekoia.io" #Added to User-Agent

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.num_assets = 1000
        self.cursor = CheckpointTimestamp(
            path=self._data_path,
            time_unit=TimeUnit.SECOND,
            start_at=timedelta(days=20),
        )
        self.from_date = self.cursor.offset

    @property
    def client(self) -> TenableIO:
        """
        Create and return a TenableIO client instance using the provided configuration.

        :return:
            TenableIO: An instance of the TenableIO client configured with the base URL, access key, and secret key.
        """
        return TenableIO(
            url=self.module.configuration["base_url"],
            access_key=self.module.configuration["access_key"],
            secret_key=self.module.configuration["secret_key"],
            vendor=self.CLIENT_VENDOR,
            product=self.CLIENT_PRODUCT
        )

    @cached_property
    def states(self) -> list[str]:
        """
        Get the list of vulnerability states.
        :return:
            list[str]: A list of vulnerability state values.
        """
        return [state.value for state in VulnerabilityState]

    @cached_property
    def severities(self) -> list[str]:
        """
        Get the list of vulnerability severities.
        :return:
            list[str]: A list of vulnerability severity values.
        """
        return [severity.value for severity in VulnerabilitySeverity]

    def extract_timestamp(self, vuln: dict) -> int:
        """
        Extract the timestamp from a vulnerability dictionary.

        :param
            vuln: Dictionary representing a vulnerability.
        :return:
            int: The timestamp in seconds.
        """
        dt = datetime.fromisoformat(vuln["first_found"])
        return int(dt.timestamp())

    def handle_activity(self, state:str) -> tuple[int|None, str|None]:
        action_map = {
            'OPEN': (1, "Create"),
            'REOPENED': (2, "Updated"),
            'FIXED': (3, "Close"),
        }
        return action_map.get(state)

    def map_vulnerability_fields(self, vuln: dict, asset_info: dict) -> VulnerabilityOCSFModel:
        """
        Map the fields of a vulnerability to the OCSF Vulnerability model.
        :param vuln:
            Dictionary representing a vulnerability from Tenable.
        :param asset_info:
            Dictionary containing asset information from Tenable.
        :return:
            VulnerabilityOCSFModel: An instance of the OCSF Vulnerability model with mapped fields.
        """

        # Get state and map it to activity_id and activity_status
        vuln_state = vuln['state']
        activity_id, activity_status = self.handle_activity(vuln_state)

        # Get plugins
        plugin = vuln.get("plugin", {})
        type_uid, type_name = 200200 + activity_id, f"Vulnerability Finding: {activity_status}"

        # Create metadata
        # TO DO: Update product version
        product = Product(name=self.PRODUCT, version="1.0.0")
        metadata = Metadata(product=product, version="1.5.0")

        # Get finding information field
        types = [plugin.get("type")] if plugin.get("type", "") else []
        finding_product = Product(name=self.PRODUCT_TYPE, version="1.0.0")
        finding_information = FindingInformation(
            uid=vuln["finding_id"], #Required
            types = types,
            data_sources=[vuln.get("source")] if vuln.get("source", "") else [],
            title=plugin.get("name", ""),
            desc=plugin.get("description", ""),
            first_seen_time=self.extract_timestamp(plugin.get("first_found")),
            last_seen_time=self.extract_timestamp(plugin.get("last_found")),
            product=finding_product,
        )

        # Map vulnerability field
        cve = CVE(
            uid=",".join(map(str, plugin.get("cve", []))),  # Required
            type=""
        )
        vulnerabilities = VulnerabilityDetails(
            cve=cve,
            title=plugin.get("name", ""),
            references=plugin.get("see_also", []),
        )

        # To Do: Add more fields about device

        return VulnerabilityOCSFModel(
            activity_id=activity_id,
            activity_name=activity_status,
            category_name="Findings",
            category_uid=2,
            class_name="Vulnerability Finding",
            class_uid=2002,
            type_name=type_name,
            type_uid=type_uid,
            time=self.extract_timestamp(vuln["first_found"]),
            metadata=metadata,
            finding_info=finding_information,
            vulnerabilities= vulnerabilities
        )

    def _get_asset_info(self, asset_uuid: str) -> dict:
        """
        Fetch asset details from Tenable using the asset UUID.

        Args:
            asset_uuid (str): The UUID of the asset to fetch details for.
        Returns:
            dict: A dictionary containing asset details.
        """
        asset_info: dict = self.client.assets.details(asset_uuid)
        return asset_info

    def _get_tenable_vul(self) -> Generator[VulnerabilityOCSFModel, None, None]:
        """
        This method retrieves vulnerabilities from Tenable using the pyTenable SDK,
        processes them, and yields them as VulnerabilityOCSFModel instances.

        :return:
            Generator[VulnerabilityOCSFModel, None, None]: A generator yielding VulnerabilityOCSFModel instances.
        """

        recent_timestamp_seen: int = self.from_date
        self.log(f"Getting vulnerabilities from tenable at {self.cursor.offset}", level="info")

        # Use pyTenable sdk to get vulnerabilities
        vulns = self.client.exports.vulns(
                    since=self.cursor.offset,
                    state=self.states,
                    severity=self.severities,
                    num_assets=self.num_assets
                )

        if len(vulns)>0 :
            for vuln in vulns:
                # Get the asset information
                asset_uuid = vuln["asset"]["uuid"]
                asset_info = self._get_asset_info(asset_uuid)

                # Map the vulnerability fields
                mapped_vuln = self.map_vulnerability_fields(vuln, asset_info)

                yield mapped_vuln

                # Update the cursor offset
                last_datetime: int = self.extract_timestamp(vuln)
                if last_datetime > recent_timestamp_seen:
                    self.cursor.offset = last_datetime
                    self.from_date = last_datetime
                    self.log(f"Last date updated to {last_datetime}", level="info")

        else :
            self.log(f"Getting no assets from tenable at {self.cursor.offset}", level="info")

    def get_assets(self) -> Generator[VulnerabilityOCSFModel, None, None]:
        self.log("Start tenable getting assets generator !!", level="info")
        for vuln in self._get_tenable_vul():
            yield vuln
